{"version":3,"file":"index.browser.min.js","sources":["../package.json","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"plugin-moving-dots-2\",\n  \"version\": \"0.0.1\",\n  \"description\": \"moving dots but better\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.cjs\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"typings\": \"dist/index.d.ts\",\n  \"unpkg\": \"dist/index.browser.min.js\",\n  \"files\": [\n    \"src\",\n    \"dist\"\n  ],\n  \"source\": \"src/index.ts\",\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm test -- --watch\",\n    \"tsc\": \"tsc\",\n    \"build\": \"rollup --config\",\n    \"build:watch\": \"npm run build -- --watch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"\",\n    \"directory\": \"./\"\n  },\n  \"keywords\": [\n    \"jsPsych\"\n  ],\n  \"author\": {\n    \"name\": \"ollie & noah\",\n    \"url\": \"\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"/issues\"\n  },\n  \"homepage\": \"/plugin-moving-dots-2/README.md\",\n  \"dependencies\": {\n    \"jspsych\": \"^8.0.0\",\n    \"@citation-js/core\": \"^0.7.14\",\n    \"@citation-js/plugin-software-formats\": \"^0.6.1\",\n    \"@citation-js/plugin-bibtex\": \"^0.7.14\",\n    \"@citation-js/plugin-cff\": \"^0.6.1\"\n  },\n  \"devDependencies\": {\n    \"@jspsych/config\": \"^3.2.2\",\n    \"@jspsych/test-utils\": \"^1.0.0\"\n  }\n}\n","// !!!TO DO: modify timing of trial to be 5 seconds for purposes of playback file collection. fix bugs\n\nimport { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\n\nimport { version } from \"../package.json\";\n\nconst info = <const>{\n  name: \"plugin-moving-dots-2\",\n  version: version,\n  parameters: {\n    /** Array of control change levels (e.g., 30%, 70%, 100%) */\n    control_levels: {\n      type: ParameterType.INT,\n      array: true,\n      default: [30, 70, 100],\n    },\n    /** Number of dots to display on the screen */\n    dot_count: {\n      type: ParameterType.INT,\n      default: 10,\n    },\n    /** Maximum initial distance from the center location for dots */\n    max_initial_distance: {\n      type: ParameterType.INT,\n      default: 100,\n    },\n    /** Duration of the flash in milliseconds */\n    flash_duration: {\n      type: ParameterType.INT,\n      default: 200,\n    },\n    /** Delay before the dot flashes in milliseconds */\n    pre_flash_duration: {\n      type: ParameterType.INT,\n      default: 2500,\n    },\n    /** Duration of the post-flash in milliseconds */\n    post_flash_duration: {\n      type: ParameterType.INT,\n      default: 1500,\n    },\n    /** Initial level of control the mouse has over the dots (0-100) */\n    initial_control_level: {\n      type: ParameterType.INT,\n      default: 100,\n    },\n    /** Change in the level of control of the flashing dot after it changes (0-100) */\n    control_change_level: {\n      type: ParameterType.INT,\n      default: 30,\n    },\n    /** 2-dimensional array of mouse data for playback */\n    playback: {\n      type: ParameterType.COMPLEX,\n      array: true,\n      default: [] as Array<{ dx: number; dy: number; t: number }>,\n      params: {\n        dx: {\n          type: ParameterType.INT,\n        },\n        dy: {\n          type: ParameterType.INT,\n        },\n        t: {\n          type: ParameterType.INT,\n        },\n      },\n    },\n  },\n  data: {\n    /** Magnitude of the control change (e.g., 30, 70, 100) */\n    control_change: {\n      type: ParameterType.INT,\n    },\n  },\n  // When you run build on your plugin, citations will be generated here based on the information in the CITATION.cff file.\n  citations: \"__CITATIONS__\",\n};\n\ntype Info = typeof info;\n\n/**\n * **plugin-moving-dots-2**\n *\n * Handles moving series of dots that move at the same speed in response to user input; one dot will flash red and change control level. Implemented as part of an experiment for COGS-219; replicating the paper \"Control Changes the Way We Look at the World\" by Wen & Haggard.\n *\n * @author Ollie & Noah\n * @see {@link /plugin-moving-dots-2/README.md}\n */\nclass MovingDots2Plugin implements JsPsychPlugin<Info> {\n  static info = info;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    // Create a canvas to display the dots\n    const canvas = document.createElement(\"canvas\");\n\n    // Change canvas size to window size\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    display_element.appendChild(canvas);\n    const ctx = canvas.getContext(\"2d\");\n\n    // Initialize dot positions and control levels\n    const dots: { x: number; y: number; control: number }[] = [];\n\n    // Flash one dot and change its control level after a random delay\n    const flashIndex = 0;\n    const controlChange = trial.control_change_level;\n\n    let flashStartTime: number | null = null;\n    let hasFlashed = false;\n    let isFlashing = false;\n\n    const data = [];\n    let frame = 0;\n\n    let startTime = Date.now();\n    let lastFrameTime = startTime;\n\n    // Handle mouse/touchpad input\n    let dx = 0;\n    let dy = 0;\n\n    let isFirstMove = true;\n\n    const initializeDots = () => {\n      for (let i = 0; i < trial.dot_count; i++) {\n        const angle = Math.random() * 2 * Math.PI;\n        const distance = Math.random() * trial.max_initial_distance;\n        dots.push({\n          x: canvas.width / 2 + distance * Math.cos(angle),\n          y: canvas.height / 2 + distance * Math.sin(angle),\n          control: trial.initial_control_level, // Initial control level\n        });\n      }\n    };\n\n    // Render dots, cross, and control value\n    const renderDotsAndCross = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      // Render cross at the center\n      ctx.beginPath();\n      ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);\n      ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);\n      ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);\n      ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Render dots\n      dots.forEach((dot, index) => {\n        ctx.beginPath();\n        ctx.arc(dot.x, dot.y, 5, 0, 2 * Math.PI);\n        if (isFlashing) {\n          ctx.fillStyle = index === flashIndex ? \"red\" : \"black\";\n        } else {\n          ctx.fillStyle = \"black\";\n        }\n        ctx.fill();\n      });\n    };\n\n    const mouseMoveListener = (e: MouseEvent) => {\n      dx = e.movementX;\n      dy = e.movementY;\n    };\n\n    // Function to calculate new dx and dy\n    const doTheMath = (\n      inputDX: number,\n      inputDY: number,\n      playbackDX: number,\n      playbackDY: number,\n      control: number\n    ) => {\n\n      const epsilon = 0.00001; // a small constant to prevent division by zero\n\n      // get magnitude of mouse vector\n      const mySpeed = Math.sqrt(Math.pow(inputDX, 2) + Math.pow(inputDY, 2)) + epsilon;\n      \n      // get unit vector of mouse vector\n      const unitVector = { x: inputDX / mySpeed, y: inputDY / mySpeed };\n\n      // get magnitude of playback vector\n      const playbackSpeed = Math.sqrt(\n        Math.pow(playbackDX, 2) + Math.pow(playbackDY, 2)\n      ) + epsilon;\n\n      // get unit vector of playback vector\n      const playbackUnitVector = {\n        x: playbackDX / playbackSpeed,\n        y: playbackDY / playbackSpeed,\n      };\n\n      // blend the two vectors based on control\n      // if control is 1 (100%), use only the mouse vector\n      // if control is 0, use only the playback vector\n\n      const newDX = (control * unitVector.x + (1 - control) * playbackUnitVector.x) * mySpeed;\n      const newDY = (control * unitVector.y + (1 - control) * playbackUnitVector.y) * mySpeed;\n      \n      return { newDX, newDY };\n    };\n\n    // Update dot positions based on control\n    const updateDots = (vx: number, vy: number) => {\n      dots.forEach((dot) => {\n        const { newDX, newDY } = doTheMath(\n          vx,\n          vy,\n          trial.playback[frame].dx,\n          trial.playback[frame].dy,\n          dot.control / 100\n        );\n        dot.x += newDX;\n        dot.y += newDY;\n      });\n    };\n\n    // End trial\n    const endTrial = () => {\n      document.removeEventListener(\"mousemove\", mouseMoveListener);\n      display_element.innerHTML = \"\"; // Clear the canvas\n      this.jsPsych.finishTrial({\n        control_change: controlChange,\n        mouse_data: data,\n      });\n    };\n\n    const animate = () => {\n      const currentTime = Date.now();\n      const elapsedTime = currentTime - startTime;\n\n      lastFrameTime = currentTime;\n\n      // working backwards from the end of the trial\n      \n      // check if the trial is over\n      if(elapsedTime >= trial.pre_flash_duration + trial.post_flash_duration) {\n        endTrial();\n        return;\n      }\n\n      // check if we are switching to the post-flash period\n      if (isFlashing && currentTime - flashStartTime >= trial.flash_duration) {\n        isFlashing = false;\n        hasFlashed = true;\n      }\n\n      // check if it is time to flash\n      if (elapsedTime >= trial.pre_flash_duration && !isFlashing && !hasFlashed) {\n        flashStartTime = Date.now();\n        isFlashing = true;\n        if (trial.initial_control_level === 100) {\n          dots[flashIndex].control = dots[flashIndex].control - controlChange;\n        } else if (trial.initial_control_level === 0) {\n          dots[flashIndex].control = dots[flashIndex].control + controlChange;\n        }\n      }\n      // run the next loop of the animation\n      updateDots(dx, dy);\n      renderDotsAndCross();\n      data.push({ dx, dy });\n      dx = 0;\n      dy = 0;\n      frame++;\n      requestAnimationFrame(animate);\n    };\n\n    initializeDots();\n    renderDotsAndCross();\n    document.addEventListener(\"mousemove\", mouseMoveListener);\n    animate();\n  }\n}\n\nexport default MovingDots2Plugin;\n"],"names":["version","info","ParameterType","MovingDots2Plugin","jsPsych","display_element","trial","canvas","ctx","dots","flashIndex","controlChange","flashStartTime","hasFlashed","isFlashing","data","frame","startTime","dx","dy","initializeDots","i","angle","distance","renderDotsAndCross","dot","index","mouseMoveListener","e","doTheMath","inputDX","inputDY","playbackDX","playbackDY","control","mySpeed","unitVector","playbackSpeed","playbackUnitVector","newDX","newDY","updateDots","vx","vy","endTrial","animate","currentTime","elapsedTime"],"mappings":"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"}