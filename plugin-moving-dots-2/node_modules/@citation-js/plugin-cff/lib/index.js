"use strict";

var _core = require("@citation-js/core");

var _date = require("@citation-js/date");

require("@citation-js/plugin-yaml");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const TYPES_TO_TARGET = {
  art: 'graphic',
  article: 'article-journal',
  audiovisual: 'motion_picture',
  bill: 'bill',
  blog: 'post-weblog',
  book: 'book',
  catalogue: 'collection',
  conference: 'event',
  'conference-paper': 'paper-conference',
  data: 'dataset',
  database: 'dataset',
  dictionary: 'entry-dictionary',
  'edited-work': 'document',
  encyclopedia: 'entry-encyclopedia',
  'film-broadcast': 'broadcast',
  generic: 'document',
  'government-document': 'regulation',
  grant: 'document',
  hearing: 'hearing',
  'historical-work': 'classic',
  'legal-case': 'legal_case',
  'legal-rule': 'legislation',
  'magazine-article': 'article-magazine',
  manual: 'report',
  map: 'map',
  multimedia: 'motion_picture',
  music: 'musical_score',
  'newspaper-article': 'article-newspaper',
  pamphlet: 'pamphlet',
  patent: 'patent',
  'personal-communication': 'personal_communication',
  proceedings: 'book',
  report: 'report',
  serial: 'periodical',
  slides: 'speech',
  software: 'software',
  'software-code': 'software',
  'software-container': 'software',
  'software-executable': 'software',
  'software-virtual-machine': 'software',
  'sound-recording': 'song',
  standard: 'standard',
  statute: 'legislation',
  thesis: 'thesis',
  unpublished: 'article',
  video: 'motion_picture',
  website: 'webpage'
};
const TYPES_TO_SOURCE = {
  article: 'article',
  'article-journal': 'article',
  'article-magazine': 'magazine-article',
  'article-newspaper': 'newspaper-article',
  bill: 'bill',
  book: 'book',
  broadcast: 'film-broadcast',
  chapter: 'generic',
  classic: 'historical-work',
  collection: 'catalogue',
  dataset: 'data',
  document: 'generic',
  entry: 'generic',
  'entry-dictionary': 'dictionary',
  'entry-encyclopedia': 'encyclopedia',
  event: 'conference',
  figure: 'generic',
  graphic: 'art',
  hearing: 'hearing',
  interview: 'sound-recording',
  legal_case: 'legal-case',
  legislation: 'statute',
  manuscript: 'historical-work',
  map: 'map',
  motion_picture: 'film-broadcast',
  musical_score: 'music',
  pamphlet: 'pamphlet',
  'paper-conference': 'conference-paper',
  patent: 'patent',
  performance: 'generic',
  periodical: 'serial',
  personal_communication: 'personal-communication',
  post: 'serial',
  'post-weblog': 'blog',
  regulation: 'government-document',
  report: 'report',
  review: 'generic',
  'review-book': 'generic',
  software: 'software',
  song: 'sound-recording',
  speech: 'slides',
  standard: 'standard',
  thesis: 'thesis',
  treaty: 'generic',
  webpage: 'website'
};
const ENTITY_PROPS = [{
  source: 'family-names',
  target: 'family'
}, {
  source: 'given-names',
  target: 'given'
}, {
  source: 'name-particle',
  target: 'non-dropping-particle'
}, {
  source: 'name-suffix',
  target: 'suffix'
}, {
  source: 'name',
  target: 'literal'
}, {
  source: 'orcid',
  target: '_orcid'
}];
const entity = new _core.util.Translator(ENTITY_PROPS);
const PROP_CONVERTERS = {
  names: {
    toTarget(names) {
      return names.map(entity.convertToTarget);
    },

    toSource(names) {
      return names.map(entity.convertToSource);
    }

  },
  publisher: {
    toTarget({
      name,
      city,
      region,
      country
    }) {
      const place = [city, region, country].filter(Boolean).join(', ');
      return [name, place || undefined];
    },

    toSource(name, place) {
      const entity = {
        name
      };

      if (place) {
        const parts = place.split(', ');
        entity.country = parts.pop();

        if (parts.length === 2) {
          entity.region = parts.pop();
        }

        if (parts.length === 1) {
          entity.city = parts.pop();
        }
      }

      return entity;
    }

  },
  date: {
    toTarget(date) {
      return (0, _date.parse)(date.toISOString());
    },

    toSource(date) {
      if (date.raw) {
        return date.raw;
      }

      const [year, month, day] = date['date-parts'][0];

      if (day) {
        return new Date(Date.UTC(year, month - 1, day));
      } else if (month) {
        return new Date(Date.UTC(year, month - 1));
      } else {
        return new Date(Date.UTC(year));
      }
    }

  }
};
const SHARED_PROPS = ['abstract', {
  source: 'authors',
  target: 'author',
  convert: PROP_CONVERTERS.names
}, {
  source: 'date-released',
  target: 'issued',
  when: {
    target: {
      type: 'software'
    }
  },
  convert: PROP_CONVERTERS.date
}, {
  source: 'doi',
  target: 'DOI'
}, {
  source: 'identifiers',
  target: ['DOI', 'ISBN', 'ISSN', 'PMCID', 'PMID', 'URL'],
  convert: {
    toTarget(identifiers) {
      const newIdentifiers = Array(6).fill(undefined);

      for (const {
        type,
        value
      } of identifiers) {
        if (!this.doi && type === 'doi') {
          newIdentifiers[0] = value;
        }

        if (!this.url && type === 'url') {
          newIdentifiers[5] = value;
        }

        if (type === 'other' && value.startsWith('urn:isbn:')) {
          newIdentifiers[1] = value.slice(9);
        }

        if (type === 'other' && value.startsWith('urn:issn:')) {
          newIdentifiers[2] = value.slice(9);
        }

        if (type === 'other' && value.startsWith('pmcid:')) {
          newIdentifiers[3] = value.slice(6);
        }

        if (type === 'other' && value.startsWith('pmid:')) {
          newIdentifiers[4] = value.slice(5);
        }
      }

      return newIdentifiers;
    },

    toSource(doi, isbn, issn, pmcid, pmid, url) {
      return [doi && {
        type: 'doi',
        value: doi
      }, url && {
        type: 'url',
        value: url
      }, isbn && {
        type: 'other',
        value: `urn:isbn:${isbn}`
      }, issn && {
        type: 'other',
        value: `urn:issn:${issn}`
      }, pmcid && {
        type: 'other',
        value: `pmcid:${pmcid}`
      }, pmid && {
        type: 'other',
        value: `pmid:${pmid}`
      }].filter(Boolean);
    }

  }
}, {
  source: 'keywords',
  target: 'keyword',
  convert: {
    toTarget(keywords) {
      return keywords.join(',');
    },

    toSource(keywords) {
      return keywords.split(/,\s*/g);
    }

  }
}, {
  source: 'title',
  target: 'title',
  when: {
    source: {
      term: false,
      entry: false
    },
    target: {
      type(type) {
        return !['entry', 'entry-dictionary', 'entry-encyclopedia'].includes(type);
      }

    }
  }
}, {
  source: 'title',
  target: 'container-title',
  when: {
    source: {
      entry: true,
      journal: false
    },
    target: {
      type: ['entry']
    }
  }
}, {
  source: 'title',
  target: 'container-title',
  when: {
    source: {
      term: true,
      journal: false
    },
    target: {
      type: ['entry-dictionary', 'entry-encyclopedia']
    }
  }
}, {
  source: 'url',
  target: 'URL'
}, 'version'];
const MAIN_PROPS = [{
  source: 'type',
  target: 'type',
  convert: {
    toSource(type) {
      return type === 'dataset' ? 'dataset' : 'software';
    },

    toTarget(type) {
      return type === 'dataset' ? 'dataset' : 'software';
    }

  }
}, ...SHARED_PROPS];
const REF_PROPS = [...SHARED_PROPS, {
  source: 'abbreviation',
  target: 'title-short'
}, {
  source: 'abbreviation',
  target: 'shortTitle'
}, 'collection-title', {
  source: 'recipients',
  target: 'recipient',
  convert: PROP_CONVERTERS.names
}, {
  source: 'senders',
  target: 'authors',
  convert: PROP_CONVERTERS.names
}, {
  source: 'conference',
  target: ['event-title', 'event-date', 'event-place', 'event'],
  convert: {
    toSource(name, date, place, nameFallback) {
      const entity = {
        name: name || nameFallback
      };

      if (place) {
        entity.location = place;
      }

      if (date) {
        entity['date-start'] = PROP_CONVERTERS.date.toSource(date);

        if (date['date-parts'] && date['date-parts'].length === 2) {
          entity['date-end'] = PROP_CONVERTERS.date.toSource({
            'date-parts': [date['date-parts'][1]]
          });
        }
      }

      return entity;
    },

    toTarget(event) {
      return [event.name, (0, _date.parse)(event['date-start'].toISOString(), event['date-end'].toISOString()), event.location];
    }

  }
}, {
  source: 'database',
  target: 'source'
}, {
  source: 'date-accessed',
  target: 'accessed',
  convert: PROP_CONVERTERS.date
}, {
  source: 'date-downloaded',
  target: 'accessed',
  convert: PROP_CONVERTERS.date,
  when: {
    source: {
      'date-accessed': false
    },
    target: false
  }
}, {
  source: 'date-published',
  target: 'issued',
  convert: PROP_CONVERTERS.date,
  when: {
    source: {
      'date-released': false
    },

    target() {
      return this.type !== 'book' || !this.version;
    }

  }
}, {
  source: ['year', 'month'],
  target: 'issued',
  when: {
    source: {
      'date-published': false,
      'date-released': false,
      year: true
    }
  },
  convert: {
    toTarget(year, month) {
      const date = month ? [year, month] : [year];
      return {
        'date-parts': [date]
      };
    },

    toSource(issued) {
      const [year, month] = issued['date-parts'][0];
      return [year, month];
    }

  }
}, {
  source: 'year-original',
  target: 'original-date',
  convert: {
    toTarget(year) {
      return {
        'date-parts': [[year]]
      };
    },

    toSource(date) {
      return date['date-parts'][0][0];
    }

  }
}, 'edition', {
  source: 'editors',
  target: 'editor',
  convert: PROP_CONVERTERS.names
}, {
  source: 'editors-series',
  target: 'collection-editor',
  convert: PROP_CONVERTERS.names
}, {
  source: 'entry',
  target: 'title',
  when: {
    source: {
      term: false
    },
    target: {
      type: 'entry'
    }
  }
}, {
  source: 'term',
  target: 'title',
  when: {
    target: {
      type: ['entry-dictionary', 'entry-encyclopedia']
    }
  }
}, {
  source: 'format',
  target: 'dimensions'
}, 'medium', {
  source: 'data-type',
  target: 'genre',
  when: {
    target: {
      type(type) {
        return type !== 'thesis';
      }

    }
  }
}, {
  source: 'thesis-type',
  target: 'genre',
  when: {
    source: {
      'data-type': false
    },
    target: {
      type: 'thesis'
    }
  }
}, {
  source: 'isbn',
  target: 'ISBN'
}, {
  source: 'issn',
  target: 'ISSN'
}, {
  source: 'pmcid',
  target: 'PMCID'
}, 'issue', {
  source: 'journal',
  target: 'container-title'
}, {
  source: 'volume-title',
  target: 'volume-title'
}, {
  source: 'issue-title',
  target: 'volume-title',
  when: {
    source: {
      'volume-title': false
    },
    target: false
  }
}, {
  source: 'languages',
  target: 'language',
  when: {
    target: true,
    source: {
      language(code) {
        return /[a-z]{2,3}/.test(code);
      }

    }
  },
  convert: {
    toSource(language) {
      return [language];
    },

    toTarget(languages) {
      return languages[0];
    }

  }
}, {
  source: 'location',
  target: ['archive', 'archive-place'],
  convert: PROP_CONVERTERS.publisher
}, {
  source: 'notes',
  target: 'note',
  when: {
    source: {
      scope: false
    }
  }
}, {
  source: 'scope',
  target: 'note',
  when: {
    target: false
  }
}, 'number', {
  source: 'patent-states',
  target: 'jurisdiction',
  when: {
    target: false
  },
  convert: {
    toTarget(states) {
      return states.join(', ');
    }

  }
}, {
  source: ['institution', 'department'],
  target: ['publisher', 'publisher-place'],
  when: {
    source: {
      publisher: false
    },
    target: {
      type: 'thesis'
    }
  },
  convert: {
    toTarget(institution, department) {
      const [name, place] = PROP_CONVERTERS.publisher.toTarget(institution);
      return [department ? `${department}, ${name}` : name, place];
    },

    toSource(name, place) {
      return [PROP_CONVERTERS.publisher.toSource(name, place)];
    }

  }
}, {
  source: 'publisher',
  target: ['publisher', 'publisher-place'],
  when: {
    target: {
      type(type) {
        return type !== 'thesis';
      }

    }
  },
  convert: PROP_CONVERTERS.publisher
}, 'section', {
  source: 'status',
  target: 'status',
  when: {
    source: true,
    target: {
      status: ['in-preparation', 'abstract', 'submitted', 'in-press', 'advance-online', 'preprint']
    }
  }
}, {
  source: 'start',
  target: 'page-first',
  when: {
    target: {
      page: false
    }
  }
}, {
  source: ['start', 'end'],
  target: 'page',
  convert: {
    toTarget(start, end) {
      return end ? `${start}-${end}` : start;
    },

    toSource(page) {
      const [start, end] = page.split('-');
      return end ? [start, end] : [start];
    }

  }
}, {
  source: 'pages',
  target: 'number-of-pages'
}, {
  source: 'translators',
  target: 'translator',
  convert: PROP_CONVERTERS.names
}, {
  source: 'type',
  target: 'type',
  convert: {
    toTarget(type) {
      return TYPES_TO_TARGET[type] || 'document';
    },

    toSource(type) {
      if (type === 'book' && this['event-title']) {
        return 'proceedings';
      }

      return TYPES_TO_SOURCE[type] || 'generic';
    }

  }
}, 'volume', {
  source: 'number-volumes',
  target: 'number-of-volumes'
}];
const mainTranslator = new _core.util.Translator(MAIN_PROPS);
const refTranslator = new _core.util.Translator(REF_PROPS);
const CFF_VERSION = '1.2.0';

function parse(input) {
  const main = mainTranslator.convertToTarget(input);

  if (input['cff-version'] <= '1.1.0') {
    main.type = TYPES_TO_TARGET.software;
  }

  main._cff_mainReference = true;
  const output = [main];

  if (input['preferred-citation']) {
    output.push(refTranslator.convertToTarget(input['preferred-citation']));
  }

  if (Array.isArray(input.references)) {
    output.push(...input.references.map(refTranslator.convertToTarget));
  }

  return output;
}

function format(input, options = {}) {
  input = input.slice();
  const {
    main,
    preferred,
    cffVersion = CFF_VERSION,
    message = 'Please cite the following works when using this software.'
  } = options;
  let preferredCitation;
  const preferredIndex = input.findIndex(entry => preferred && entry.id === preferred);

  if (cffVersion >= '1.2.0' && preferredIndex > -1) {
    preferredCitation = refTranslator.convertToSource(...input.splice(preferredIndex, 1));
  }

  let mainIndex = input.findIndex(entry => main ? entry.id === main : entry._cff_mainReference);
  mainIndex = mainIndex > -1 ? mainIndex : 0;
  const mainRef = input[mainIndex] ? mainTranslator.convertToSource(...input.splice(mainIndex, 1)) : {};

  if (mainRef && cffVersion < '1.2.0') {
    delete mainRef.type;
  }

  const cff = _objectSpread({
    'cff-version': cffVersion,
    message
  }, mainRef);

  if (preferredCitation) {
    cff['preferred-citation'] = preferredCitation;
  }

  if (input.length) {
    cff.references = input.map(refTranslator.convertToSource);
  }

  return cff;
}

_core.plugins.add('@cff', {
  input: {
    '@cff/object': {
      parseType: {
        dataType: 'SimpleObject',
        propertyConstraint: {
          props: 'cff-version'
        }
      },
      parse: parse
    }
  },
  output: {
    cff(data, options = {}) {
      const output = format(data, options);

      if (options.type === 'object') {
        return output;
      } else {
        return _core.plugins.output.format('yaml', output);
      }
    }

  }
});